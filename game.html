<html>
<head>
  <meta charset="utf-8">
  <title>Игра на three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1"></script>
    <script type="module">
    // Импортируем модуль three.js
    import * as THREE from "https://threejs.org/build/three.module.js";
// Создаем рендерер
const renderer = new THREE.WebGLRenderer();

// Задаем размер и цвет фона рендерера
renderer.setSize(window.innerWidth, window.innerHeight); // ширина и высота окна браузера
renderer.setClearColor(0x87ceeb); // светло-голубой цвет

// Добавляем холст рендерера в документ
document.body.appendChild(renderer.domElement);


    // Создаем сцену
    const scene = new THREE.Scene();

    // Создаем перспективную камеру
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Задаем положение и направление камеры
    camera.position.set(0, 10, 20); // x, y, z
    camera.lookAt(0, 0, 0); // центр сцены

// Создаем амбиент свет
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // белый цвет и высокая интенсивность

// Добавляем амбиент свет в сцену
scene.add(ambientLight);


    // Создаем направленный свет (солнце)
const sun = new THREE.DirectionalLight(0xffffff, 1.0);

// Задаем положение и направление света
sun.position.set(100, 200, -100); // x, y, z
sun.target.position.set(0, 0, 0); // центр сцены

// Включаем тени в рендерере
renderer.shadowMap.enabled = true;

// Задаем свету свойство castShadow
sun.castShadow = true;

// Настройки теней для солнца
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far = 500;

// Добавляем солнце в сцену
scene.add(sun);


// Создаем геометрию для морской поверхности (океана)
const seaGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);

// Создаем текстуру для морской поверхности (океана)
const seaTexture = new THREE.TextureLoader().load('assets/water.png');
seaTexture.wrapS = THREE.RepeatWrapping;
seaTexture.wrapT = THREE.RepeatWrapping;
seaTexture.repeat.set(10, 10);

// Создаем материал для морской поверхности (океана) с использованием текстуры
const seaMaterial = new THREE.MeshStandardMaterial({
  map: seaTexture,
  color: 0x008080, // Цвет морской поверхности без текстуры
});

// Создаем меш морской поверхности (океана) из геометрии и материала
const sea = new THREE.Mesh(seaGeometry, seaMaterial);

// Поворачиваем морскую поверхность (океан) по оси x на -90 градусов
sea.rotation.x = -Math.PI / 2;

// Помещаем морскую поверхность (океан) ниже островов
sea.position.y = -0.9;

// Добавляем меш морской поверхности (океана) в сцену
scene.add(sea);

    
// Создаем геометрию и материал для островов
const islandGeometry = new THREE.PlaneGeometry(1000, 1000, 50, 50);
const islandMaterial = new THREE.MeshPhongMaterial({ color: 0xf4a460 }); // Красный цвет
    function islandNoise(x, y) {
      const simplex = new SimplexNoise();
      return simplex.noise2D(x, y) * 50;
    }
     function updateIsland() {
      const positionAttribute = islandGeometry.getAttribute("position");
      const colorAttribute = islandGeometry.getAttribute("color"); // Получаем атрибут с цветами вершин
      for (let i = 0; i < positionAttribute.count; i++) {
        const x = positionAttribute.getX(i);
        const y = positionAttribute.getY(i);
        const z = Math.random() * 10;
        positionAttribute.setZ(i, z);
        
      }
      positionAttribute.needsUpdate = true;
     }
    const island = new THREE.Mesh(islandGeometry, islandMaterial);
    island.rotation.x = -Math.PI / 2;
    island.position.y = -5;
    scene.add(island);




    // Создаем геометрию и материал для корабля (куба)
    const shipGeometry = new THREE.BoxGeometry(1, 1, 1);
    const shipMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Красный цвет

    // Создаем меш корабля из геометрии и материала
    const ship = new THREE.Mesh(shipGeometry, shipMaterial);

    // Помещаем корабль на определенную высоту над водой
    ship.position.y = 1;

    // Добавляем меш корабля в сцену
    scene.add(ship);

    // Параметры для управления кораблем
const shipControls = {
  moveForward: false,
  moveBackward: false,
  turnLeft: false,
  turnRight: false
};

// Обработчик события при нажатии клавиши
function onKeyDown(event) {
  const keyCode = event.keyCode;

  // Нажата клавиша "W" - движение вперед
  if (keyCode === 87) {
    shipControls.moveForward = true;
  }
  // Нажата клавиша "S" - движение назад
  else if (keyCode === 83) {
    shipControls.moveBackward = true;
  }
  // Нажата клавиша "A" - поворот влево
  else if (keyCode === 65) {
    shipControls.turnLeft = true;
  }
  // Нажата клавиша "D" - поворот вправо
  else if (keyCode === 68) {
    shipControls.turnRight = true;
  }
}

// Обработчик события при отпускании клавиши
function onKeyUp(event) {
  const keyCode = event.keyCode;

  // Отпущена клавиша "W" - остановить движение вперед
  if (keyCode === 87) {
    shipControls.moveForward = false;
  }
  // Отпущена клавиша "S" - остановить движение назад
  else if (keyCode === 83) {
    shipControls.moveBackward = false;
  }
  // Отпущена клавиша "A" - остановить поворот влево
  else if (keyCode === 65) {
    shipControls.turnLeft = false;
  }
  // Отпущена клавиша "D" - остановить поворот вправо
  else if (keyCode === 68) {
    shipControls.turnRight = false;
  }
}

// Добавляем обработчики событий
document.addEventListener("keydown", onKeyDown);
document.addEventListener("keyup", onKeyUp);

// Параметры для управления скоростью и поворотом корабля
const shipSpeed = 0.05;
const turnSpeed = 0.03;
let shipVelocity = new THREE.Vector3(0, 0, 0);

function updateShip() {
  // В этой функции мы будем обрабатывать управление кораблем и его перемещение

  // Если корабль поворачивается влево, поворачиваем его влево
  if (shipControls.turnLeft) {
    ship.rotation.y += turnSpeed; // Поворачиваем корабль влево
  }

  // Если корабль поворачивается вправо, поворачиваем его вправо
  if (shipControls.turnRight) {
    ship.rotation.y -= turnSpeed; // Поворачиваем корабль вправо
  }

  // Двигаем корабль вперед или назад в зависимости от управления
  const angle = ship.rotation.y;
  const dx = Math.sin(angle);
  const dz = Math.cos(angle);

  if (shipControls.moveForward) {
    shipVelocity.x -= dx * shipSpeed;
    shipVelocity.z += dz * shipSpeed;
  }

  if (shipControls.moveBackward) {
    shipVelocity.x += dx * shipSpeed;
    shipVelocity.z -= dz * shipSpeed;
  }

  // Применяем затухание скорости, чтобы корабль остановился после отпускания клавиш управления
  shipVelocity.x *= 0.9;
  shipVelocity.z *= 0.9;

  // Обновляем позицию корабля
  ship.position.add(shipVelocity);
}

updateIsland();

// Создаем часы
const clock = new THREE.Clock();

function animate() {
  // Запрашиваем новый кадр
  requestAnimationFrame(animate);

  // Получаем время с предыдущего кадра
  const deltaTime = clock.getDelta();

  // Обновляем корабль с учетом deltaTime
  updateShip(deltaTime);

  camera.position.copy(ship.position);
  camera.position.y += 10; // Поднимаем камеру над кораблем
  camera.position.z += 20; // Перемещаем камеру немного назад относительно корабля
  camera.lookAt(ship.position); // Направляем камеру на корабль

  // Отрисовываем сцену и камеру
  renderer.render(scene, camera);
}
animate();

</script>

<div id="result"></div>

</body>
</html>
