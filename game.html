<!DOCTYPE html>
<html>
<head>
    <title>2D Online Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Устанавливаем размер холста на основе размера окна браузера
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Вызываем функцию resizeCanvas при загрузке и изменении размера окна
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);

        const ws = new WebSocket('wss://intermediate-easy-ship.glitch.me');
        const players = new Map();
        const trails = new Map(); // Массив для следов

        // Границы игровой области
        const gameBounds = {
            left: 0,
            top: 0,
            right: canvas.width,
            bottom: canvas.height
        };

        // Управление для каждого игрока
        const playerControls = new Map();

        // Объявление переменных для камеры
        let cameraOffsetX = 0;
        let cameraOffsetY = 0;

        ws.onopen = () => {
            console.log('Connected to server');
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'playerInfo') {
                createOrUpdatePlayer(data);
            } else if (data.type === 'playerUpdate') {
                updatePlayerPosition(data);
            } else if (data.type === 'playerDisconnect') {
                removePlayer(data.id);
            }
        };

        function createOrUpdatePlayer(playerData) {
            if (!players.has(playerData.id)) {
                // Генерируем случайный цвет
                playerData.color = getRandomColor();
                players.set(playerData.id, playerData);
                trails.set(playerData.id, []);
                playerControls.set(playerData.id, { up: false, down: false, left: false, right: false });
            } else {
                players.set(playerData.id, { ...players.get(playerData.id), ...playerData });
            }

            drawPlayers();
        }

        function updatePlayerPosition(playerData) {
            createOrUpdatePlayer(playerData);
            // Добавляем след при обновлении позиции игрока
            trails.get(playerData.id).push({ x: playerData.x, y: playerData.y, alpha: 1.0 });
        }

        function removePlayer(playerId) {
            players.delete(playerId);
            trails.delete(playerId);
            playerControls.delete(playerId);
            drawPlayers();
        }

        function drawPlayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Рассчитываем смещение для камеры каждого игрока
            for (const [playerId, player] of players.entries()) {
                const currentPlayerX = player.x;
                const currentPlayerY = player.y;

                const cameraOffsetX = currentPlayerX - canvas.width / 2;
                const cameraOffsetY = currentPlayerY - canvas.height / 2;

                // Проверяем, чтобы камера не выходила за границы игровой области
                let cameraX = cameraOffsetX;
                let cameraY = cameraOffsetY;

                if (cameraX < gameBounds.left) {
                    cameraX = gameBounds.left;
                } else if (cameraX + canvas.width > gameBounds.right) {
                    cameraX = gameBounds.right - canvas.width;
                }

                if (cameraY < gameBounds.top) {
                    cameraY = gameBounds.top;
                } else if (cameraY + canvas.height > gameBounds.bottom) {
                    cameraY = gameBounds.bottom - canvas.height;
                }

                canvas.style.transform = `translate(${-cameraX}px, ${-cameraY}px)`;

                // Рисуем игрока
                ctx.fillStyle = player.color || 'blue';
                ctx.fillRect(currentPlayerX - cameraX, currentPlayerY - cameraY, 20, 20);

                // Рисуем и обновляем следы
                const playerTrails = trails.get(playerId);
                for (let i = 0; i < playerTrails.length; i++) {
                    ctx.fillStyle = 'rgba(255, 0, 0, ' + playerTrails[i].alpha + ')';
                    ctx.fillRect(playerTrails[i].x - cameraX, playerTrails[i].y - cameraY, 20, 20);
                    playerTrails[i].alpha -= 0.01; // Уменьшаем прозрачность следа
                    if (playerTrails[i].alpha <= 0) {
                        playerTrails.splice(i, 1); // Удаляем след, когда прозрачность достигает 0
                    }
                }
            }
        }

        // Генерация случайного цвета
        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Обработчики событий для управления каждым игроком
        function handleControls() {
            window.addEventListener('keydown', (event) => {
                const playerId = getPlayerId();
                if (playerId && playerControls.has(playerId)) {
                    const controls = playerControls.get(playerId);
                    switch (event.key) {
                        case 'ArrowUp':
                            controls.up = true;
                            break;
                        case 'ArrowDown':
                            controls.down = true;
                            break;
                        case 'ArrowLeft':
                            controls.left = true;
                            break;
                        case 'ArrowRight':
                            controls.right = true;
                            break;
                    }
                }
            });

            window.addEventListener('keyup', (event) => {
                const playerId = getPlayerId();
                if (playerId && playerControls.has(playerId)) {
                    const controls = playerControls.get(playerId);
                    switch (event.key) {
                        case 'ArrowUp':
                            controls.up = false;
                            break;
                        case 'ArrowDown':
                            controls.down = false;
                            break;
                        case 'ArrowLeft':
                            controls.left = false;
                            break;
                        case 'ArrowRight':
                            controls.right = false;
                            break;
                    }
                }
            });

            // Обработчик клика для установки целевой позиции
            canvas.addEventListener('click', (event) => {
                const rect = canvas.getBoundingClientRect();
                targetX = event.clientX - rect.left + cameraOffsetX;
                targetY = event.clientY - rect.top + cameraOffsetY;
            });
        }
        handleControls();

        // Инициализация начальной целевой позиции
        let targetX = canvas.width / 2;
        let targetY = canvas.height / 2;

        // Получение ID текущего игрока
        function getPlayerId() {
            const urlParams = new URLSearchParams(window.location.search);
            return urlParams.get('playerId');
        }
    </script>
</body>
</html>
