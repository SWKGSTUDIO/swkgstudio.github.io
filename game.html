<!DOCTYPE html>
<html>
<head>
    <title>2D Online Game</title>

    <!-- Yandex.RTB -->
    <script>window.yaContextCb=window.yaContextCb||[]</script>
    <script src="https://yandex.ru/ads/system/context.js" async></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        #gameCanvas {
            width: 100%;
            height: 100vh;
            display: block;
            background-color: black;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <!-- Yandex.RTB R-A-2938411-1 -->
    <script>window.yaContextCb.push(()=>{
        Ya.Context.AdvManager.render({
            "blockId": "R-A-2938411-1",
            "type": "fullscreen",
            "platform": "touch"
        })
    })
    </script>

    <!-- Yandex.RTB R-A-2938411-5 -->
    <script>window.yaContextCb.push(()=>{
        Ya.Context.AdvManager.render({
            "blockId": "R-A-2938411-5",
            "type": "fullscreen",
            "platform": "desktop"
        })
    })
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Устанавливаем размер холста на основе размера окна браузера
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        // Вызываем функцию resizeCanvas при загрузке и изменении размера окна
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('load', resizeCanvas);

        const ws = new WebSocket('wss://intermediate-easy-ship.glitch.me');
        const players = new Map();
        const trails = new Map(); // Мап для следов

        // Текущая позиция игрока
        let currentPlayerX = canvas.width / 2;
        let currentPlayerY = canvas.height / 2;

        // Текущий угол поворота игрока
        let currentAngle = 0;

        // Целевая позиция для движения игрока
        let targetX = currentPlayerX;
        let targetY = currentPlayerY;

        // Определение переменных для камеры
        let cameraX = canvas.width / 2;
        let cameraY = canvas.height / 2;

        ws.onopen = () => {
            console.log('Connected to server');
        };

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'playerInfo') {
                createOrUpdatePlayer(data);
            } else if (data.type === 'playerUpdate') {
                updatePlayerPosition(data);
            } else if (data.type === 'playerDisconnect') {
                removePlayer(data.id);
            }
        };

        function createOrUpdatePlayer(playerData) {
            if (!players.has(playerData.id)) {
                players.set(playerData.id, playerData);
            } else {
                players.set(playerData.id, { ...players.get(playerData.id), ...playerData });
            }

            drawPlayers();
        }

        function updatePlayerPosition(playerData) {
            createOrUpdatePlayer(playerData);
            const player = players.get(playerData.id);

            const playerTrail = trails.get(playerData.id);

            if (!playerTrail) {
                trails.set(playerData.id, []);
            }

            const updatedTrail = trails.get(playerData.id);

            updatedTrail.push({ x: playerData.x, y: playerData.y, alpha: 1.0 });
        }

        function removePlayer(playerId) {
            players.delete(playerId);
            trails.delete(playerId);
            drawPlayers();
        }

        function drawPlayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            cameraX = currentPlayerX - canvas.width / 2;
            cameraY = currentPlayerY - canvas.height / 2;

            trails.forEach((playerTrails, playerId) => {
                const player = players.get(playerId);
                const playerColor = player.color || 'red';

                ctx.strokeStyle = playerColor;
                ctx.lineWidth = 10;
                ctx.lineCap = 'round';

                playerTrails.forEach((trail, index) => {
                    const trailX = trail.x - cameraX;
                    const trailY = trail.y - cameraY;

                    if (index === 0) {
                        ctx.beginPath();
                        ctx.moveTo(trailX, trailY);
                    } else {
                        // Рисуем кривую Безье между предыдущей точкой и текущей
                        const prevTrail = playerTrails[index - 1];
                        const cpX = (trailX + prevTrail.x - cameraX) / 2;
                        const cpY = (trailY + prevTrail.y - cameraY) / 2;
                        ctx.quadraticCurveTo(prevTrail.x - cameraX, prevTrail.y - cameraY, cpX, cpY);
                    }
                });

                ctx.stroke();
            });

            players.forEach((player, playerId) => {
                ctx.fillStyle = player.color || 'blue';
                const x = player.x - cameraX;
                const y = player.y - cameraY;
                const radius = 10; // Радиус игрока (можете настроить подходящий размер)
                
                // Рисуем игрока как круг
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, Math.PI * 2);
                ctx.fill();
                ctx.closePath();
            });
        }

        canvas.addEventListener('click', (event) => {
            const rect = canvas.getBoundingClientRect();
            targetX = event.clientX - rect.left + cameraX;
            targetY = event.clientY - rect.top + cameraY;
        });

        const updateInterval = 16; // Примерно 60 кадров в секунду
        let playerSpeed = 2.5; // Начальная скорость игрока
        const turnSpeed = 0.03; // Скорость поворота игрока (меньше значение = медленнее поворот)

        window.addEventListener('wheel', (event) => {
            // Изменяем скорость игрока в зависимости от направления прокрутки колесика мыши
            playerSpeed += event.deltaY > 0 ? -0.1 : 0.1;

            // Ограничиваем скорость, чтобы она не стала слишком маленькой или слишком большой
            if (playerSpeed < 0.1) {
                playerSpeed = 0.1;
            } else if (playerSpeed > 5) {
                playerSpeed = 5;
            }
        });

        // Минимальная дистанция, на которую игрок будет замедляться и останавливаться
const minDistance = 25;

function moveCurrentPlayer() {
    const dx = targetX - currentPlayerX;
    const dy = targetY - currentPlayerY;
    const distance = Math.sqrt(dx * dx + dy * dy); // Расстояние до цели

    if (distance > minDistance) {
        const angle = Math.atan2(dy, dx);
        const angleDiff = angle - currentAngle;

        // Плавное изменение угла
        if (angleDiff > Math.PI) {
            currentAngle += 2 * Math.PI;
        } else if (angleDiff < -Math.PI) {
            currentAngle -= 2 * Math.PI;
        }

        currentAngle += angleDiff * turnSpeed;

        // Ограничиваем скорость, чтобы игрок мог замедлиться и остановиться
        if (distance < playerSpeed) {
            currentPlayerX = targetX;
            currentPlayerY = targetY;
        } else {
            currentPlayerX += Math.cos(currentAngle) * playerSpeed;
            currentPlayerY += Math.sin(currentAngle) * playerSpeed;
        }
    }

    if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({
            type: 'playerPosition',
            x: currentPlayerX,
            y: currentPlayerY,
            trail: { x: currentPlayerX, y: currentPlayerY, alpha: 1.0 },
        }));
    }

    drawPlayers();
}

        function animate() {
            moveCurrentPlayer();
            requestAnimationFrame(animate);
        }

        animate();
    </script>
</body>
</html>
