<html>
<head>
  <meta charset="utf-8">
  <title>Игра на three.js</title>
  <style>
    body { margin: 0; }
    canvas { display: block; }
  </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1"></script>
    <script src="https://cdn.jsdelivr.net/npm/three-obj-loader@1.1.3/dist/index.min.js"></script>

    <script type="module">
    import * as THREE from "https://threejs.org/build/three.module.js";

const renderer = new THREE.WebGLRenderer();
renderer.setSize(window.innerWidth, window.innerHeight); // ширина и высота окна браузера
renderer.setClearColor(0x87ceeb); // светло-голубой цвет

document.body.appendChild(renderer.domElement);


    // Создаем сцену
    const scene = new THREE.Scene();

    // Создаем перспективную камеру
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

    // Задаем положение и направление камеры
    camera.position.set(0, 10, 20); // x, y, z
    camera.lookAt(0, 0, 0); // центр сцены

// Создаем амбиент свет
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); // белый цвет и высокая интенсивность

// Добавляем амбиент свет в сцену
scene.add(ambientLight);


// Создаем направленный свет (солнце)
const sun = new THREE.DirectionalLight(0xffffff, 1.0);

// Задаем положение и направление света
sun.position.set(100, 200, -100); // x, y, z
sun.target.position.set(0, 0, 0); // центр сцены

// Включаем тени в рендерере
renderer.shadowMap.enabled = true;

// Задаем свету свойство castShadow
sun.castShadow = true;

// Настройки теней для солнца
sun.shadow.mapSize.width = 2048;
sun.shadow.mapSize.height = 2048;
sun.shadow.camera.near = 0.5;
sun.shadow.camera.far = 500;

// Добавляем солнце в сцену
scene.add(sun);


// Глобальная переменная для хранения времени
let time = 0;

// Функция для обновления морской поверхности на каждом кадре
function updateSea() {
  // Увеличиваем время на шаг
  time += 0.01;

  // Получаем доступ к текстуре материала морской поверхности
  const seaTexture = sea.material.map;

  // Изменяем текстурные координаты на основе значения шума для анимации
  for (let i = 0; i < sea.geometry.vertices.length; i++) {
    const vertex = sea.geometry.vertices[i];
    vertex.z = noise.noise2D(vertex.x * 0.02, vertex.y * 0.02 + time * 0.2) * 2;
  }

  // Помечаем геометрию как измененную
  sea.geometry.verticesNeedUpdate = true;

  // Обновляем повторение текстуры, чтобы она перемещалась вместе с анимацией
  seaTexture.offset.y += 0.1;
}




// ОСТРОВА
    
  function generateRandomIslandGeometry() {
  const geometries = [
  new THREE.CylinderGeometry(5 + Math.random() * 10, 5 + Math.random() * 10, 1 + Math.random() * 5, 16)
  ];
  return geometries[Math.floor(Math.random() * geometries.length)];
  }
  const islands = [];
  // Создаем несколько островов и добавляем их в сцену
  for (let i = 0; i < 10; i++) {
  const islandGeometry = generateRandomIslandGeometry();
  const islandMaterial = new THREE.MeshPhongMaterial({ color: 0xC2B280 });
  const islandMesh = new THREE.Mesh(islandGeometry, islandMaterial);
  // Располагаем остров случайным образом на сцене
  islandMesh.position.x = Math.random() * 250 - 50;
  islandMesh.position.z = Math.random() * 250 - 50;
  // Получаем размеры острова
  const islandBoundingBox = new THREE.Box3().setFromObject(islandMesh);
  const islandHeight = islandBoundingBox.max.y - islandBoundingBox.min.y;
  // Поднимаем остров на половину его высоты, чтобы его нижняя часть была на уровне воды
  islandMesh.position.y = -islandHeight / 3;
  scene.add(islandMesh);
  islands.push(islandMesh);
}



    // КОРБАЛЬ
    const shipGeometry = new THREE.BoxGeometry(2, 1, 1);
    const shipMaterial = new THREE.MeshPhongMaterial({ color: 0xff0000 }); // Красный цвет
    const ship = new THREE.Mesh(shipGeometry, shipMaterial);
    ship.position.y = 1;
    scene.add(ship);
     // Контроллер для камеры
    const cameraControls = new THREE.Object3D();
    cameraControls.add(camera);
    scene.add(cameraControls);
    const shipDirection = new THREE.Vector3(0, 0, 1); // Направление движения корабля (вперед)
    // Параметры для управления кораблем
    const shipControls = {
    moveForward: false,
    moveBackward: false,
    turnLeft: false,
    turnRight: false
};

// Обработчик события при нажатии клавиши
function onKeyDown(event) {
  const keyCode = event.keyCode;
  // Нажата клавиша "W" - движение вперед
  if (keyCode === 87) {
    shipControls.moveForward = true;
  }
  // Нажата клавиша "S" - движение назад
  else if (keyCode === 83) {
    shipControls.moveBackward = true;
  }
  // Нажата клавиша "A" - поворот влево
  else if (keyCode === 65) {
    shipControls.turnLeft = true;
  }
  // Нажата клавиша "D" - поворот вправо
  else if (keyCode === 68) {
    shipControls.turnRight = true;
  }
}
// Обработчик события при отпускании клавиши
function onKeyUp(event) {
  const keyCode = event.keyCode;
  // Отпущена клавиша "W" - остановить движение вперед
  if (keyCode === 87) {
    shipControls.moveForward = false;
  }
  // Отпущена клавиша "S" - остановить движение назад
  else if (keyCode === 83) {
    shipControls.moveBackward = false;
  }
  // Отпущена клавиша "A" - остановить поворот влево
  else if (keyCode === 65) {
    shipControls.turnLeft = false;
  }
  // Отпущена клавиша "D" - остановить поворот вправо
  else if (keyCode === 68) {
    shipControls.turnRight = false;
  }
}

// Добавляем обработчики событий
document.addEventListener("keydown", onKeyDown);
document.addEventListener("keyup", onKeyUp);

// Параметры для управления скоростью и поворотом корабля
const shipSpeed = 0.5;
const turnSpeed = 0.03;
let shipVelocity = new THREE.Vector3(0, 0, 0);

function updateShip() {
  // В этой функции мы будем обрабатывать управление кораблем и его перемещение

  // Если корабль поворачивается влево, поворачиваем его влево
  if (shipControls.turnLeft) {
    ship.rotation.y += turnSpeed; // Поворачиваем корабль влево
  }

  // Если корабль поворачивается вправо, поворачиваем его вправо
  if (shipControls.turnRight) {
    ship.rotation.y -= turnSpeed; // Поворачиваем корабль вправо
  }

  // Обновляем направление движения корабля на основе его поворота
  shipDirection.set(0, 0, 1);
  shipDirection.applyAxisAngle(new THREE.Vector3(0, 1, 0), ship.rotation.y);

  // Двигаем корабль вперед или назад в зависимости от управления
  if (shipControls.moveForward) {
    ship.position.add(shipDirection.clone().multiplyScalar(-shipSpeed)); // Перемещаем корабль вперед
  }

  if (shipControls.moveBackward) {
    ship.position.add(shipDirection.clone().multiplyScalar(shipSpeed)); // Перемещаем корабль назад
  }
  // Двигаем корабль вперед или назад в зависимости от управления
  const angle = ship.rotation.y;
  const dx = Math.sin(angle);
  const dz = Math.cos(angle);

  // Применяем затухание скорости, чтобы корабль остановился после отпускания клавиш управления
  shipVelocity.x *= 0.9;
  shipVelocity.z *= 0.9;

  // Обновляем позицию корабля
  ship.position.add(shipVelocity);
  // Логируем позицию корабля после обновления в элемент <div> с id="result"
}


 // Создаем океан
 const oceanGeometry = new THREE.PlaneGeometry(2000, 2000, 100, 100);

// Загружаем текстуру воды
const waterTexture = new THREE.TextureLoader().load("path/to/your/water_texture.jpg");
waterTexture.wrapS = waterTexture.wrapT = THREE.RepeatWrapping;
waterTexture.repeat.set(20, 20); // Увеличиваем повторение текстуры, чтобы океан выглядел более реалистично

// Создаем материал для водной поверхности
const waterMaterial = new THREE.ShaderMaterial({
    uniforms: {
      uTime: { value: 0.0 }, // Переменная для передачи времени в шейдер
    },
    vertexShader: `
      uniform float uTime;
      varying vec2 vUv;

      void main() {
        vUv = uv;
        vec3 transformed = position.xyz;
        float amplitude = 0.5; // Амплитуда волн
        float frequency = 3.5; // Частота волн
        transformed.z += amplitude * sin(uv.x * frequency + uTime) * cos(uv.y * frequency + uTime);
        gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed, 1.0);
      }
    `,
    fragmentShader: `
      uniform float uTime;
      varying vec2 vUv;

      void main() {
        // Простой голубой цвет для водной поверхности
        vec3 waterColor = vec3(0.2, 0.5, 0.8);

        // Эффект глубины в зависимости от позиции y
        float depth = (1.0 - gl_FragCoord.z) * 10.0;

        // Добавляем глубинный эффект к цвету
        gl_FragColor = vec4(waterColor - depth, 1.0);
      }
    `,
    side: THREE.DoubleSide,
  });

  // Создаем океан с заданным материалом
  const ocean = new THREE.Mesh(oceanGeometry, waterMaterial);
  ocean.rotation.x = -Math.PI / 2; // Поворачиваем океан горизонтально
  ocean.receiveShadow = true; // Позволяем океану принимать тени
  scene.add(ocean);



// Создаем часы
const clock = new THREE.Clock();

function animate() {
  // Запрашиваем новый кадр
  requestAnimationFrame(animate);

  // Получаем время с предыдущего кадра
  const deltaTime = clock.getDelta();

  updateShip(deltaTime);

  // Обновляем анимацию волн
  waterMaterial.uniforms.uTime.value += 0.01;

   // Перемещаем камеру относительно корабля
   const distance = 30; // Расстояние от корабля до камеры по оси z
    const offsetX = Math.sin(ship.rotation.y) * distance; // Смещение по оси x
    const offsetZ = Math.cos(ship.rotation.y) * distance; // Смещение по оси z
    camera.position.set(ship.position.x + offsetX, ship.position.y + 10, ship.position.z + offsetZ);

    // Направляем камеру на корабль
    camera.lookAt(ship.position);


  // Отрисовываем сцену и камеру
  renderer.render(scene, camera);
}
animate();

</script>

<div id="result"></div>

</body>
</html>
