<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Управляемый кубик</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #pauseButton {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: #333;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>
    <div id="pauseButton">Пауза</div>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>


    <script>
        
        const zombies = [];
        let isPaused = false;

        document.addEventListener("DOMContentLoaded", function () {
            const canvas = document.getElementById("renderCanvas");
            const engine = new BABYLON.Engine(canvas, true);

            const resizeCanvas = function () {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            };

            resizeCanvas();

            window.addEventListener("resize", function () {
                resizeCanvas();
                engine.resize();
            });

            const createScene = function () {
                const scene = new BABYLON.Scene(engine);
                scene.enablePhysics();

                const ground = BABYLON.Mesh.CreateGround("ground", 20000, 20000, 1, scene, false);
                ground.position.y = -0.5;
                ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 1 }, scene);

                const sandTexture = new BABYLON.Texture("gameassets/sand.png", scene);
                const sandMaterial = new BABYLON.StandardMaterial("sandMaterial", scene);
                sandMaterial.diffuseTexture = sandTexture;
                sandMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                sandMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                sandMaterial.ambientColor = new BABYLON.Color3(1, 1, 1);
                ground.material = sandMaterial;

                const box = BABYLON.Mesh.CreateBox("box", 1, scene);
                box.position.y = 10;
                box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 5 }, scene);


                const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 0, box.position, scene);
                camera.lowerRadiusLimit = 5;
                camera.upperRadiusLimit = 20;
                camera.attachControl(canvas, true);


                scene.registerBeforeRender(function() {
                    camera.target = box.position.clone();
                });

                const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(0, -1, -0.5), scene);
                light.castShadow = true;

                let canControl = false;

                const inputMap = {};
                scene.actionManager = new BABYLON.ActionManager(scene);
                scene.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnKeyDownTrigger,
                        function (evt) {
                            if (canControl) {
                                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                                if (evt.sourceEvent.key == " ") {
                                    box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 3, 0), box.getAbsolutePosition());
                                }
                            }
                        }
                    )
                );
                scene.actionManager.registerAction(
                    new BABYLON.ExecuteCodeAction(
                        BABYLON.ActionManager.OnKeyUpTrigger,
                        function (evt) {
                            if (canControl) {
                                inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                            }
                        }
                    )
                );

                setInterval(function () {
                    const zombie = createZombie(scene, box, zombies);
                    zombies.push(zombie);
                }, 999);

                scene.onBeforeRenderObservable.add(() => {
                    if (box.intersectsMesh(ground, false) && !canControl) {
                        canControl = true;
                        ground.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                    }

                    if (canControl) {
                        if (inputMap["w"]) {
                            box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 0, 0.3), box.getAbsolutePosition());
                        }
                        if (inputMap["s"]) {
                            box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 0, -0.3), box.getAbsolutePosition());
                        }
                        if (inputMap["a"]) {
                            box.physicsImpostor.applyImpulse(new BABYLON.Vector3(-0.3, 0, 0), box.getAbsolutePosition());
                        }
                        if (inputMap["d"]) {
                            box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0.3, 0, 0), box.getAbsolutePosition());
                        }
                    }

                    
                    // Удаление зомби, находящихся ниже определенной высоты (например, -10)
                    for (let i = zombies.length - 1; i >= 0; i--) {
                    const zombie = zombies[i];
                    if (zombie.position.y < -2) {
                    // Удаление зомби из массива и сцены
                    zombies.splice(i, 1);
                    zombie.dispose();
        }
    }

    // Код управления зомби
        for (const zombie of zombies) {
        const direction = box.position.subtract(zombie.position);
        direction.normalize();
        const force = direction.scale(10); 
        zombie.physicsImpostor.applyForce(force, zombie.getAbsolutePosition());
    }
});

                return scene;
            };

            const scene = createScene();

            engine.runRenderLoop(function () {
                if (!isPaused) {
                    scene.render();
                }
            });

            const pauseButton = document.getElementById("pauseButton");
            pauseButton.addEventListener("click", function () {
                isPaused = !isPaused;
                if (isPaused) {
                    pauseButton.innerText = "Продолжить";
                } else {
                    pauseButton.innerText = "Пауза";
                }
            });
        });

        function createZombie(scene, player, zombies) {
    const zombie = BABYLON.Mesh.CreateBox("zombie", 1, scene);
    zombie.position = new BABYLON.Vector3(player.position.x + Math.random() * 100 - 50, 1, player.position.z + Math.random() * 100 - 50);
    zombie.scaling = new BABYLON.Vector3(0.1, 0.1, 0.1); // Установка масштаба 0.5 по всем осям

    // Создайте физическое тело зомби с учетом его нового размера
    const size = 0.5; // Новый размер зомби
    const boundingBox = new BABYLON.Vector3(size, size, size);
    zombie.physicsImpostor = new BABYLON.PhysicsImpostor(zombie, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.1, friction: 5, size: boundingBox }, scene);

    const zombieMaterial = new BABYLON.StandardMaterial("zombieMaterial", scene);
    zombieMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
    zombie.material = zombieMaterial;

    zombie.actionManager = new BABYLON.ActionManager(scene);
    zombie.actionManager.registerAction(
        new BABYLON.ExecuteCodeAction(
            BABYLON.ActionManager.OnPickTrigger,
            function () {
                createExplosion(scene, zombie.position);
                const index = zombies.indexOf(zombie);
                if (index !== -1) {
                    zombies.splice(index, 1);
                }
                zombie.dispose();
            }
        )
    );
    return zombie;
}


function createExplosion(scene, position) {
    const particleSystem = new BABYLON.ParticleSystem("explosion", 2000, scene);
    particleSystem.particleTexture = new BABYLON.Texture("gameassets/particle.png", scene);
    particleSystem.emitter = position;
    particleSystem.minEmitBox = new BABYLON.Vector3(0, 0, 0);
    particleSystem.maxEmitBox = new BABYLON.Vector3(0, 0, 0);

    // Установка цвета частиц (белый)
    particleSystem.color1 = new BABYLON.Color4(1, 1, 1, 1);
    particleSystem.color2 = new BABYLON.Color4(1, 1, 1, 1);
    particleSystem.colorDead = new BABYLON.Color4(1, 1, 1, 0);

    particleSystem.minSize = 0.1;
    particleSystem.maxSize = 1;
    particleSystem.minLifeTime = 0.5; // Уменьшим время жизни частиц
    particleSystem.maxLifeTime = 1.0;
    particleSystem.emitRate = 20000;

    // Гравитация для частиц (падают вниз)
    particleSystem.gravity = new BABYLON.Vector3(0, -100, 0);

    // Установка начальной скорости частиц
    particleSystem.minInitialSpeed = 300;
    particleSystem.maxInitialSpeed = 600;

    // Установка радиального направления движения частиц
    particleSystem.direction1 = new BABYLON.Vector3(1, 1, 1);
    particleSystem.direction2 = new BABYLON.Vector3(-1, -1, -1);

    // Установка угловой скорости для реалистичного разлета
    particleSystem.minAngularSpeed = -Math.PI;
    particleSystem.maxAngularSpeed = Math.PI;

    // Установка силы выпуска частиц для эффекта разлета
    particleSystem.minEmitPower = 100;
    particleSystem.maxEmitPower = 150;

    particleSystem.updateSpeed = 0.005;

    particleSystem.start();

    setTimeout(function () {
        particleSystem.stop();
        particleSystem.dispose();
    }, 100);
}




    </script>
</body>
</html>
