<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATTACK CUBE</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: black;
        }
        canvas {
            display: block;
        }
        #pauseButton {
            position: absolute;
            top: 20px;
            left: 20px;
            opacity: 0;
            background-color: #333;
            color: white;
            padding: 10px 20px;
            cursor: pointer;
        }

        #playButton {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #ff5722;
            color: white;
            border: none;
            border-radius: 5px;
            padding: 15px 30px;
            font-size: 24px;
            cursor: pointer;
            transition: background-color 0.3s ease-in-out;
        }

        #playButton:hover {
            background-color: #ff7043;
        }

        #playButton:focus {
            outline: none;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        #statusMessage {
            color: white;
        }
    </style>

    <script>window.yaContextCb=window.yaContextCb||[]</script>
    <script src="https://yandex.ru/ads/system/context.js" async></script>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/cannon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>

<body>
    <div id="startScreen" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center;">
        <button id="playButton">PLAY</button>
    </div>
    <canvas id="renderCanvas"></canvas>
    <div id="pauseButton">Pause</div>
    <div id="statusMessage"></div>
    <canvas id="nicknameCanvas" width="800" height="600"></canvas>

    <!-- Yandex.RTB R-A-2938411-1 -->
    <script>window.yaContextCb.push(()=>{
        Ya.Context.AdvManager.render({
            "blockId": "R-A-2938411-1",
            "type": "fullscreen",
            "platform": "touch"
        })
    })
    </script>

    <!-- Yandex.RTB R-A-2938411-5 -->
    <script>window.yaContextCb.push(()=>{
        Ya.Context.AdvManager.render({
            "blockId": "R-A-2938411-5",
            "type": "fullscreen",
            "platform": "desktop"
        })
    })
    </script>

<script>
    const players = [];
    let isPaused = false;
    let scene = null;
    let playerMesh; // Variable to hold the player's mesh
    const ws = new WebSocket('wss://intermediate-easy-ship.glitch.me');

    ws.addEventListener('open', (event) => {
        console.log('Connected to server');
        ws.send(JSON.stringify({ type: 'message', text: 'Hello, server!' }));
    });

    ws.addEventListener('message', (event) => {
        console.log('Received message:', event.data);
        const data = JSON.parse(event.data);

        if (data.type === 'playerInfo') {
            // Create a new player mesh
            createPlayer(data);
        } else if (data.type === 'playerUpdate') {
            // Update an existing player's position
            updatePlayerInfo(data);
        } else if (data.type === 'playerDisconnect') {
            const playerId = data.id;
            const playerIndex = players.findIndex((p) => p.id === playerId);
            if (playerIndex !== -1) {
                // Handle player disconnection (e.g., remove player from the scene)
                players.splice(playerIndex, 1);
            }
        }
    });

    ws.addEventListener('error', (error) => {
        console.error('WebSocket error:', error);
    });

    ws.addEventListener('close', (event) => {
        console.log('Connection closed');
    });

    document.addEventListener("DOMContentLoaded", function () {
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const resizeCanvas = function () {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        };

        resizeCanvas();

        window.addEventListener("resize", function () {
            resizeCanvas();
            engine.resize();
        });

        const createScene = function () {
            scene = new BABYLON.Scene(engine);
            scene.enablePhysics();
            const ground = BABYLON.Mesh.CreateGround("ground", 20000, 20000, 1, scene, false);
            ground.position.y = -0.5;
            ground.physicsImpostor = new BABYLON.PhysicsImpostor(ground, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, friction: 1 }, scene);
            const sandTexture = new BABYLON.Texture("gameassets/sand.png", scene);
            const sandMaterial = new BABYLON.StandardMaterial("sandMaterial", scene);
            sandMaterial.diffuseTexture = sandTexture;
            sandMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
            sandMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
            sandMaterial.ambientColor = new BABYLON.Color3(1, 1, 1);
            ground.material = sandMaterial;
            const box = BABYLON.Mesh.CreateBox("box", 1, scene);
            box.position.y = 10;
            box.physicsImpostor = new BABYLON.PhysicsImpostor(box, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, friction: 5 }, scene);
            const camera = new BABYLON.ArcRotateCamera("camera", 0, 0, 0, box.position, scene);
            camera.lowerRadiusLimit = 5;
            camera.upperRadiusLimit = 20;
            camera.attachControl(canvas, true);
            scene.registerBeforeRender(function () {
                camera.target = box.position.clone();
            });
            const light = new BABYLON.DirectionalLight("light", new BABYLON.Vector3(0, -1, -0.5), scene);
            light.castShadow = true;
            let canControl = false;
            const inputMap = {};
            scene.actionManager = new BABYLON.ActionManager(scene);
            scene.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnKeyDownTrigger,
                    function (evt) {
                        if (canControl) {
                            inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                            if (evt.sourceEvent.key == " ") {
                                box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 3, 0), box.getAbsolutePosition());
                            }
                        }
                    }
                )
            );
            scene.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnKeyUpTrigger,
                    function (evt) {
                        if (canControl) {
                            inputMap[evt.sourceEvent.key] = evt.sourceEvent.type == "keydown";
                        }
                    }
                )
            );
            setInterval(function () {
                const zombie = createZombie(scene, box);
            }, 999);
            scene.onBeforeRenderObservable.add(() => {
                if (box.intersectsMesh(ground, false) && !canControl) {
                    canControl = true;
                    ground.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                }
                if (canControl) {
                    if (inputMap["w"]) {
                        box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 0, 0.3), box.getAbsolutePosition());
                    }
                    if (inputMap["s"]) {
                        box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0, 0, -0.3), box.getAbsolutePosition());
                    }
                    if (inputMap["a"]) {
                        box.physicsImpostor.applyImpulse(new BABYLON.Vector3(-0.3, 0, 0), box.getAbsolutePosition());
                    }
                    if (inputMap["d"]) {
                        box.physicsImpostor.applyImpulse(new BABYLON.Vector3(0.3, 0, 0), box.getAbsolutePosition());
                    }
                }
            });
            
            return scene;
        };

        const startScreen = document.getElementById("startScreen");
        const playButton = document.getElementById("playButton");
        playButton.addEventListener("click", function () {
            if (!scene) {
                scene = createScene();
                startScreen.style.display = "none";
                engine.runRenderLoop(function () {
                    if (!isPaused) {
                        scene.render();
                    }
                });
            }
        });

        function createPlayer(playerInfo) {
            if (!playerMesh) {
                playerMesh = BABYLON.Mesh.CreateBox("player", 1, scene);
                // Customize player appearance, position, etc. based on playerInfo
                // For example, you can set the player's color, position, and other properties here
                // Example: playerMesh.material = new BABYLON.StandardMaterial("playerMaterial", scene);
                // Example: playerMesh.material.diffuseColor = new BABYLON.Color3(1, 0, 0); // Red color
            }
        }

        function updatePlayerInfo(playerInfo) {
            // Update the player's position based on playerInfo
            if (playerMesh) {
                playerMesh.position.x = playerInfo.x;
                playerMesh.position.y = playerInfo.y;
                playerMesh.position.z = playerInfo.z;
            }
        }

        function createZombie(scene, player) {
            const zombie = BABYLON.Mesh.CreateBox("zombie", 1, scene);
            zombie.position = new BABYLON.Vector3(player.position.x + Math.random() * 100 - 50, 1, player.position.z + Math.random() * 100 - 50);
            zombie.scaling = new BABYLON.Vector3(0.25, 0.25, 0.25);
            const size = 0.5;
            const boundingBox = new BABYLON.Vector3(size, size, size);
            zombie.physicsImpostor = new BABYLON.PhysicsImpostor(zombie, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0.1, friction: 5, size: boundingBox }, scene);
            const zombieMaterial = new BABYLON.StandardMaterial("zombieMaterial", scene);
            zombieMaterial.diffuseColor = new BABYLON.Color3(0, 1, 0);
            zombie.material = zombieMaterial;
            zombie.actionManager = new BABYLON.ActionManager(scene);
            zombie.actionManager.registerAction(
                new BABYLON.ExecuteCodeAction(
                    BABYLON.ActionManager.OnPickTrigger,
                    function () {
                        const index = zombies.indexOf(zombie);
                        if (index !== -1) {
                            zombies.splice(index, 1);
                        }
                        zombie.dispose();
                    }
                )
            );
            return zombie;
        }
    });
</script>
</body>
</html>
